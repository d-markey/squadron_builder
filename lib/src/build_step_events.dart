import 'package:build/build.dart';
import 'package:meta/meta.dart';
import 'package:pub_semver/pub_semver.dart';

import '_analyzer_helpers.dart';

/// Class for build step events (additional assets)
@internal
abstract class BuildStepEvent {
  BuildStepEvent(this.buildStep);

  final BuildStep buildStep;
}

@internal
class ImportDetails {
  ImportDetails(this.prefix, this.platformSpecific);

  String prefix;
  Map<String, String>? platformSpecific;
}

/// Assemble multiple code parts generated by a single library. Merges imports, entry
/// points and code parts into a single asset.
@internal
class BuildStepCodeEvent extends BuildStepEvent {
  BuildStepCodeEvent(super.buildStep, this._libraryName);

  final _assetImports = <AssetId, Map<String, ImportDetails>>{};
  final _webEntryPoints = <AssetId, Set<String>>{};
  final _assetCodeParts = <AssetId, Set<String>>{};

  final String? _libraryName;

  var _warn = false;

  void mergeWith(BuildStepCodeEvent other) {
    var alreadyWarned = _warn;
    for (var entry in other._assetImports.entries) {
      _warn |= entry.key.path.contains('.web.');
      final otherImports = other._assetImports[entry.key] ?? {};
      for (var otherImport in otherImports.entries) {
        _import(
          entry.key,
          otherImport.key,
          otherImport.value.prefix,
          otherImport.value.platformSpecific,
        );
      }
    }
    for (var entry in other._webEntryPoints.entries) {
      _warn |= entry.key.path.contains('.web.');
      final webEntryPoints = _webEntryPoints.putIfAbsent(entry.key, () => {});
      webEntryPoints.addAll(entry.value);
    }
    for (var entry in other._assetCodeParts.entries) {
      _warn |= entry.key.path.contains('.web.');
      final codeParts = _assetCodeParts.putIfAbsent(entry.key, () => {});
      codeParts.addAll(entry.value);
    }
    if (!alreadyWarned && _warn) {
      log.warning(
        'Library $_libraryName defines multiple services including some targetting Web platforms. '
        'This will fail in production as each Web Worker needs its own URL and its own communication channel. '
        'Web workers services must be implemented in separate libraries. '
        'If necessary, code generation for Web platforms can be turned off with @SquadronService(targetPlatform: TargetPlatform.vm).',
      );
    }
  }

  Iterable<AssetId> get assets =>
      Set.from(_assetImports.keys.followedBy(_assetCodeParts.keys));

  String _getConditionalImport(MapEntry<String, String> entry) =>
      'if (dart.library.${entry.key}) \'${entry.value}\'';

  String _getImportCode(MapEntry<String, ImportDetails> entry) {
    final alias = entry.value.prefix.isEmpty ? '' : ' as ${entry.value.prefix}';
    final platforms = entry.value.platformSpecific?.entries ?? [];
    return '''import '${entry.key}'
        ${platforms.map(_getConditionalImport).join('\n')}$alias;
      ''';
  }

  Iterable<String> getCode(AssetId asset) sync* {
    final imports = _assetImports[asset];
    if (imports != null) yield* imports.entries.map(_getImportCode);
    final webEntryPoints = _webEntryPoints[asset];
    if (webEntryPoints != null && webEntryPoints.isNotEmpty) {
      yield '''void main() {
          ${webEntryPoints.join('\n')}
        }''';
    }
    final codeParts = _assetCodeParts[asset];
    if (codeParts != null) yield* codeParts;
  }

  bool _isAlreadyImported(String library, Map<String, ImportDetails> imports) {
    for (var entry in imports.entries) {
      if (entry.key == library) {
        return true;
      }
      final platformImports = entry.value.platformSpecific?.values ?? [];
      if (platformImports.any((item) => item == library)) {
        return true;
      }
    }
    return false;
  }

  void _import(AssetId asset, String library, String prefix,
      [Map<String, String>? platformSpecific]) {
    final imports = _assetImports.putIfAbsent(asset, () => {});
    library = library.trim();
    // library = library.trim();
    if (_isAlreadyImported(library, imports)) {
      // library is already imported, either directly or as a platform specific library
      return;
    }
    // register library + merge platform specific libraries if any
    if (!imports.containsKey(library)) {
      imports[library] = ImportDetails(prefix, platformSpecific);
    } else {
      final existingSpecific = imports[library];
      if (existingSpecific == null) {
        imports[library] = ImportDetails(prefix, platformSpecific);
      } else if (platformSpecific != null) {
        existingSpecific.platformSpecific ??= {};
        for (var entry in platformSpecific.entries) {
          existingSpecific.platformSpecific![entry.key] = entry.value;
        }
      }
    }
    // if a previously imported library is also conditionally imported, remove it from imports
    final platformLibraries = platformSpecific?.values ?? [];
    imports.removeWhere((key, value) => platformLibraries.contains(key));
  }

  void import(AssetId asset, AssetId target,
          {String prefix = '', Map<String, AssetId>? platformSpecific}) =>
      _import(
          asset,
          asset.relativePathTo(target),
          prefix,
          platformSpecific?.map(
            (key, value) => MapEntry(key, asset.relativePathTo(value)),
          ));

  void importSquadron(AssetId asset, String alias) {
    _import(asset, 'package:squadron/squadron.dart', alias);
  }

  void importDartCore(AssetId asset, String alias) {
    if (alias.isNotEmpty) _import(asset, 'dart:core', alias);
  }

  void addWebEntryPoint(AssetId asset, String webEntryPoint) {
    final webEntryPoints = _webEntryPoints.putIfAbsent(asset, () => {});
    webEntryPoints.add(webEntryPoint);
  }

  void add(AssetId asset, String code) {
    final codeParts = _assetCodeParts.putIfAbsent(asset, () => {});
    codeParts.add(code.trim());
  }
}

/// Code event emitted when a library has been fully processed
@internal
class BuildStepDoneEvent extends BuildStepEvent {
  BuildStepDoneEvent(super.buildStep, LibraryElement lib)
      : languageVersion = lib.languageVersion.package;

  final Version languageVersion;
}

extension on AssetId {
  String relativePathTo(AssetId target) {
    final targetSegments = target.pathSegments;
    final currentSegments = pathSegments;

    while (targetSegments.isNotEmpty &&
        currentSegments.isNotEmpty &&
        targetSegments.first == currentSegments.first) {
      targetSegments.removeAt(0);
      currentSegments.removeAt(0);
    }

    while (currentSegments.length > 1) {
      targetSegments.insert(0, '..');
      currentSegments.removeAt(0);
    }

    return targetSegments.join('/');
  }
}
