import 'package:analyzer/dart/element/element.dart';
import 'package:build/build.dart';
import 'package:meta/meta.dart';

/// Class for build step events (additional assets)
@internal
abstract class BuildStepEvent {
  BuildStepEvent(this.buildStep);

  final BuildStep buildStep;
}

@internal
class ImportDetails {
  ImportDetails(this.prefix, this.platformSpecific);

  String prefix;
  Map<String, String>? platformSpecific;
}

/// Assemble multiple code parts generated by a single library. Merges imports, entry
/// points and code parts into a single asset.
@internal
class BuildStepCodeEvent extends BuildStepEvent {
  BuildStepCodeEvent(super.buildStep, this._class);

  final _assetImports = <AssetId, Map<String, ImportDetails>>{};
  final _webEntryPoints = <AssetId, Set<String>>{};
  final _assetCodeParts = <AssetId, Set<String>>{};

  final ClassElement _class;

  var _warn = false;

  void mergeWith(BuildStepCodeEvent other) {
    var alreadyWarned = _warn;
    for (var entry in other._assetImports.entries) {
      _warn |= entry.key.path.contains('.web.');
      final otherImports = other._assetImports[entry.key] ?? {};
      for (var otherImport in otherImports.entries) {
        import(entry.key, otherImport.key,
            prefix: otherImport.value.prefix,
            platformSpecific: otherImport.value.platformSpecific);
      }
    }
    for (var entry in other._webEntryPoints.entries) {
      _warn |= entry.key.path.contains('.web.');
      final webEntryPoints = _webEntryPoints.putIfAbsent(entry.key, () => {});
      webEntryPoints.addAll(entry.value);
    }
    for (var entry in other._assetCodeParts.entries) {
      _warn |= entry.key.path.contains('.web.');
      final codeParts = _assetCodeParts.putIfAbsent(entry.key, () => {});
      codeParts.addAll(entry.value);
    }
    if (!alreadyWarned && _warn) {
      log.warning(
          'Library ${_class.library.librarySource.shortName} defines multiple '
          'services including some targetting Web platforms. This will fail '
          'in production as each Web Worker needs its own URL and its own '
          'communication channel. Web workers services must be implemented '
          'in separate libraries. If necessary, code generation for Web '
          'platforms can be turned off with @SquadronService(web: false).');
    }
  }

  Iterable<AssetId> get assets =>
      Set.from(_assetImports.keys.followedBy(_assetCodeParts.keys));

  String _getConditionalImport(MapEntry<String, String> entry) =>
      'if (dart.library.${entry.key}) \'${entry.value}\'';

  String _getImportCode(MapEntry<String, ImportDetails> entry) {
    final alias = entry.value.prefix.isEmpty ? '' : ' as ${entry.value.prefix}';
    final platforms = entry.value.platformSpecific?.entries ?? [];
    return '''import '${entry.key}'
        ${platforms.map(_getConditionalImport).join('\n')}$alias;
      ''';
  }

  Iterable<String> getCode(AssetId asset) sync* {
    final imports = _assetImports[asset];
    if (imports != null) yield* imports.entries.map(_getImportCode);
    final webEntryPoints = _webEntryPoints[asset];
    if (webEntryPoints != null && webEntryPoints.isNotEmpty) {
      yield '''void main() {
          ${webEntryPoints.join('\n')}
        }''';
    }
    final codeParts = _assetCodeParts[asset];
    if (codeParts != null) yield* codeParts;
  }

  bool _isAlreadyImported(String library, Map<String, ImportDetails> imports) {
    for (var entry in imports.entries) {
      if (entry.key == library) {
        return true;
      }
      final platformImports = entry.value.platformSpecific?.values ?? [];
      if (platformImports.any((item) => item == library)) {
        return true;
      }
    }
    return false;
  }

  void import(AssetId asset, String library,
      {String prefix = '', Map<String, String>? platformSpecific}) {
    final imports = _assetImports.putIfAbsent(asset, () => {});
    library = library.trim();
    if (_isAlreadyImported(library, imports)) {
      // library is already imported, either directly or as a platform specific library
      return;
    }
    // register library + merge platform specific libraries if any
    if (!imports.containsKey(library)) {
      imports[library] = ImportDetails(prefix, platformSpecific);
    } else {
      final existingSpecific = imports[library];
      if (existingSpecific == null) {
        imports[library] = ImportDetails(prefix, platformSpecific);
      } else if (platformSpecific != null) {
        existingSpecific.platformSpecific ??= {};
        for (var entry in platformSpecific.entries) {
          existingSpecific.platformSpecific![entry.key] = entry.value;
        }
      }
    }
    // if a previously imported library is also conditionally imported, remove it from imports
    final platformLibraries = platformSpecific?.values ?? [];
    imports.removeWhere((key, value) => platformLibraries.contains(key));
  }

  void addWebEntryPoint(AssetId asset, String webEntryPoint) {
    final webEntryPoints = _webEntryPoints.putIfAbsent(asset, () => {});
    webEntryPoints.add(webEntryPoint);
  }

  void add(AssetId asset, String code) {
    final codeParts = _assetCodeParts.putIfAbsent(asset, () => {});
    codeParts.add(code.trim());
  }
}

/// Code event emitted when a library has been fully processed
@internal
class BuildStepDoneEvent extends BuildStepEvent {
  BuildStepDoneEvent(super.buildStep);
}
